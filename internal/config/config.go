package config

import (
	"bufio"
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"
)

const (
	ConfigDirName  = "adhanctl"
	ConfigFileName = "config"
)

type Config struct {
	City      string
	Country   string
	Latitude  float64
	Longitude float64
	Method    int
	School    int
	AmPm      bool
	Arabic    bool
	Short     bool
	CacheSecs int
	Interval  time.Duration
}

func Default() *Config {
	return &Config{
		Method:    3,
		School:    0,
		CacheSecs: 3 * 3600,
		Interval:  time.Minute,
	}
}

func (c *Config) HasCoordinates() bool {
	return c.Latitude != 0 && c.Longitude != 0
}

func (c *Config) HasLocation() bool {
	return c.HasCoordinates() || (c.City != "" && c.Country != "")
}

func (c *Config) Validate() error {
	if !c.HasLocation() {
		return fmt.Errorf("no location configured: provide city/country or coordinates")
	}
	return nil
}

func ConfigPath() string {
	var base string
	if x := os.Getenv("XDG_CONFIG_HOME"); x != "" {
		base = filepath.Join(x, ConfigDirName)
	} else {
		home := os.Getenv("HOME")
		if home == "" {
			home = "."
		}
		base = filepath.Join(home, ".config", ConfigDirName)
	}
	return filepath.Join(base, ConfigFileName)
}

func Load() (*Config, error) {
	cfg := Default()
	path := ConfigPath()

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return cfg, nil
		}
		return nil, fmt.Errorf("reading config: %w", err)
	}

	scanner := bufio.NewScanner(strings.NewReader(string(data)))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		parts := strings.SplitN(line, "=", 2)
		if len(parts) != 2 {
			continue
		}

		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "city":
			cfg.City = value
		case "country":
			cfg.Country = value
		case "latitude":
			cfg.Latitude, _ = strconv.ParseFloat(value, 64)
		case "longitude":
			cfg.Longitude, _ = strconv.ParseFloat(value, 64)
		case "method":
			cfg.Method, _ = strconv.Atoi(value)
		case "school":
			cfg.School, _ = strconv.Atoi(value)
		case "ampm":
			cfg.AmPm = value == "true"
		case "arabic":
			cfg.Arabic = value == "true"
		case "short":
			cfg.Short = value == "true"
		case "cache_secs":
			cfg.CacheSecs, _ = strconv.Atoi(value)
		case "interval":
			d, err := time.ParseDuration(value)
			if err == nil {
				cfg.Interval = d
			}
		}
	}

	return cfg, nil
}

func (c *Config) Save() error {
	path := ConfigPath()
	dir := filepath.Dir(path)

	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("creating config directory: %w", err)
	}

	var sb strings.Builder
	sb.WriteString("# adhanctl configuration\n")
	sb.WriteString("# Generated by 'adhanctl config init'\n\n")

	if c.City != "" {
		fmt.Fprintf(&sb, "city = %s\n", c.City)
	}
	if c.Country != "" {
		fmt.Fprintf(&sb, "country = %s\n", c.Country)
	}
	if c.Latitude != 0 {
		fmt.Fprintf(&sb, "latitude = %.6f\n", c.Latitude)
	}
	if c.Longitude != 0 {
		fmt.Fprintf(&sb, "longitude = %.6f\n", c.Longitude)
	}
	fmt.Fprintf(&sb, "method = %d\n", c.Method)
	fmt.Fprintf(&sb, "school = %d\n", c.School)
	fmt.Fprintf(&sb, "ampm = %t\n", c.AmPm)
	fmt.Fprintf(&sb, "arabic = %t\n", c.Arabic)
	fmt.Fprintf(&sb, "short = %t\n", c.Short)
	fmt.Fprintf(&sb, "cache_secs = %d\n", c.CacheSecs)
	fmt.Fprintf(&sb, "interval = %s\n", c.Interval)

	if err := os.WriteFile(path, []byte(sb.String()), 0o644); err != nil {
		return fmt.Errorf("writing config: %w", err)
	}

	return nil
}

var CalculationMethods = map[int]string{
	1:  "University of Islamic Sciences, Karachi",
	2:  "Islamic Society of North America (ISNA)",
	3:  "Muslim World League",
	4:  "Umm Al-Qura University, Makkah",
	5:  "Egyptian General Authority of Survey",
	8:  "Gulf Region",
	9:  "Kuwait",
	10: "Qatar",
	11: "Majlis Ugama Islam Singapura, Singapore",
	12: "Union Organization Islamic de France",
	13: "Diyanet İşleri Başkanlığı, Turkey",
	14: "Spiritual Administration of Muslims of Russia",
	15: "Moonsighting Committee Worldwide",
	16: "Dubai",
	17: "Jabatan Kemajuan Islam Malaysia (JAKIM)",
	18: "Tunisia",
	19: "Algeria",
	20: "Kementerian Agama Republik Indonesia",
	21: "Morocco",
	22: "Comunidade Islamica de Lisboa",
	23: "Ministry of Awqaf, Islamic Affairs and Holy Places, Jordan",
}

var Schools = map[int]string{
	0: "Shafi",
	1: "Hanafi",
}

type Interactor interface {
	Prompt(prompt string) (string, error)
	PromptDefault(prompt, defaultValue string) (string, error)
	PromptChoice(prompt string, choices map[int]string) (int, error)
}

type StdioInteractor struct {
	Logger *slog.Logger
}

func (s *StdioInteractor) Prompt(prompt string) (string, error) {
	fmt.Printf("%s: ", prompt)
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(input), nil
}

func (s *StdioInteractor) PromptDefault(prompt, defaultValue string) (string, error) {
	if defaultValue != "" {
		fmt.Printf("%s [%s]: ", prompt, defaultValue)
	} else {
		fmt.Printf("%s: ", prompt)
	}
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		return "", err
	}
	input = strings.TrimSpace(input)
	if input == "" {
		return defaultValue, nil
	}
	return input, nil
}

func (s *StdioInteractor) PromptChoice(prompt string, choices map[int]string) (int, error) {
	fmt.Printf("%s:\n", prompt)
	keys := make([]int, 0, len(choices))
	for k := range choices {
		keys = append(keys, k)
	}
	sort.Ints(keys)
	for _, k := range keys {
		fmt.Printf("  %2d: %s\n", k, choices[k])
	}
	fmt.Print("Enter number: ")
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString('\n')
	if err != nil {
		return 0, err
	}
	input = strings.TrimSpace(input)
	val, err := strconv.Atoi(input)
	if err != nil {
		return 0, fmt.Errorf("invalid number: %s", input)
	}
	if _, ok := choices[val]; !ok {
		return 0, fmt.Errorf("invalid choice: %d", val)
	}
	return val, nil
}

func RunConfigInit(interactor Interactor) (*Config, error) {
	cfg := Default()

	fmt.Println("\nadhanctl - First Run Setup")
	fmt.Println("==========================")

	city, err := interactor.Prompt("City")
	if err != nil {
		return nil, err
	}
	cfg.City = city

	country, err := interactor.Prompt("Country")
	if err != nil {
		return nil, err
	}
	cfg.Country = country

	fmt.Println()
	method, err := interactor.PromptChoice("Calculation Method", CalculationMethods)
	if err != nil {
		return nil, err
	}
	cfg.Method = method

	fmt.Println()
	school, err := interactor.PromptChoice("Asr Calculation School", Schools)
	if err != nil {
		return nil, err
	}
	cfg.School = school

	ampm, err := interactor.PromptDefault("Use 12-hour format (AM/PM)", "false")
	if err != nil {
		return nil, err
	}
	cfg.AmPm = ampm == "true" || ampm == "yes" || ampm == "y"

	arabic, err := interactor.PromptDefault("Display Hijri month/weekday in Arabic", "false")
	if err != nil {
		return nil, err
	}
	cfg.Arabic = arabic == "true" || arabic == "yes" || arabic == "y"

	return cfg, nil
}
